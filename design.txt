Eric Cochran
Final Project Design

PART 1 (Multi-level hash):

Maintain pointer to "root" node.

class MLH_node:
array of 5 keys
array of 5 pointers to data
array of 5 pointers to next nodes
integer of number of elements stored at or below this node "num_elements"
friend function which overrides <<
print function which is called by <<  This will recursively print out all elements stored
in child nodes, or just num_elements, total steps, deepest level, and number of nodes depending 
on private field called "set_print_option"
-setter to modifer "set_print_option" remotely


class MLH:

-fields for deepest level, num_elements, and deepest level reached thus far
-arrays called "contract keys" and "contract data" used to store the keys and
the data beneath a node that we must contract down to.  These values will then 
be transferred to the node to which we contract.

root node;
current_array[MAX_LEVELS]; //pointer to all "important" nodes when going down

insert (key, data_type data):
-set current_level to 0
-set current_node_index to 0 //how many nodes have we visited so far?
-for loop through current_array
    -set all to NULL
set "current node" to "root node"
-loop while true:
    -if pointer where key hashes is null:
        -if num_elements == 5:
            -for loop through key array:
                -if "key" found, return 0;  //duplicate
            -for loop through current_array (index i):
                increment current_array[i].num_elements;
        -while (true):
            //-increment num_elements
            -for loop through key array (index i):
                -see what node k[i] maps to (and create if doesn't exist)
                -place this in empty key slot of this new node (and data)
                -update num_elements of node being created
            -set current_node to where "key" hashes to
            -increment current level
                -if (num_elements < 5)
                    -set key array at [num_elements] to "key"
                        (also set data)
                    -increment num_elements
        -if (num_elements < 5): //we know current node is a leaf node
            -for loop through current node's array of keys 
                -if key is there, return 0 //insert failed
                -else, place key in this array at position num_elements
        -else:
            -add 1 to num_element
            -for loop through "index i" current_array:
                -increment current_array[i];
            -create new node
            -insert key and data pointer into this new node
            -add 1 to num_elements (on this new node)
            -return 1
   -else if (pointer not null):
       -set current node to this pointer
       -set current_array[current_array_index] to current_node
       -increment current_level
end method


mlh_node delete (key):
set current_level to 0
-for loop through current_array
    -set all to NULL
-set "current node" to the root node
-while(true):
    -if (current_node != root_node and num_elements = 1):
        -at current_node, remove first element of key array (w corr. data)
        -at current_array[current_level] hash key and delete that node
        -Call "Contract Node" subroutine
    -else if (num_elements > 1 and num_elements < 6):
        -at current_node, search through key array for "key" 
            -delete data here
            -Call "Contract Node" subroutine
            -set contract_node keys and data equal to corresponding
               temporary arrays
            -return the data if found //success
        -return null pointer  //failure
    -else if (num_elements == 6):
        set "contract node" to current node
    -else //num_elements > 6
        -store current_node in current_array
        -increment current_level
        -look at node where "key" maps
End Method

//helper method to delete, called when element is deleted to go back
//to highest level where the numeber of elements on or under the node is 5
Contract Node (contract node pointer):
-if contract node not null:
    recursively call this function on each child

-if (leaf node):
    search node for keys and data and place this into contract_keys and
    contract_data arrays

End Method

*data get (key):
-set "current node" to root node
-while(curr_elements at currNode is >= 6)
    -look at third pointer array to see where "key" maps to
    -if this pointer is NULL:
        return NULL
    -else
        set current node to the value of this pointer
End while loop

//if it's a leaf node
-for loop from 0 to max_elements (5) in the key array
    -if the key is there
         return pointer to this     
    -else
         return NULL
end method

PART 2( vehicle implementation): 

-Create classes for Vehicle, Car, Hybrid, Motorcycle, Bus, and Task
-Also create a driver program

Task:
-Make vehicle class a friend of this class so vehicle class can manipulate
linked list of tasks
-Have fields for name, cost of parts, labor, and pointer to next task.
-initialize first three int the constructor.


Vehicle:
constructor: set all required fields
destrucotor: free the linked list of tasks and set relevent pointers to null
add Task: Create a new task and set its next pointer to "first_task.next"
and then set that pointer to this new task
display_initial_info: Make this virtual as Car will override this.  This method will display to the screen preliminary vehicle info such as id, cost, and mileage
print: Also to be made virtual since dervied classes will have their own print.  But here, just go through the tasks and calculate total cost.
>> operator: Call the print function and return the ostream


Car (derived from vehicle):
-Constructor: call parent constructor and set more fields
-display_initial_info: call parent function and add relvelent data that only cars have that generic vehicles do not
-print: call display_initial_info (on vehicle) and then and car-specific data and then vall vehicle print. 


Hybrid (derived from Car):
-Everything is analagous to the car class

Motorcycle (derived from vehicle):
-analogous to Car class

Bus (derived from vehicle):
-analogous to Car class

Main class:
-initialize an mlh object
-have it be a menu-based application which begins by providing a menu to 
the user - which will have the options of adding a vehicle, checking out a 
vehicle, viewing a vehicle status, adding a task to a vehicle, and finally, displaying all vehicles currently in service.  This will be controlled by 
a switch statement.  For adding a vehicle, there will be another switch statment asking about the type of vehicle.  Then, a new vehicle object will be stored in the data strucutre, and will be deleted if the insertion fails.  For checking out a vehicle, the user will be asked as to what the key is that should be deleted.  The mlh_delete will then be called on that key and deleted, but if it fails, the user will be notified.  Also, the bill will be printed using <<.  Next, viewing a vehicle just entails asking for an id and getting that from the mlh and printing that vehicle.  Adding a task is similar, but when the vehicle is found, add_task() will be called.  Finally, viewing all vehicles will print the whole mlh.
